#!/bin/bash
# FPM Coverage Bridge Script
# Bridges the gap between simple README patterns and complex FPM build directories
# Implements the documented simple patterns by handling FPM complexity internally

set -e

# Configuration
PROJECT_ROOT="$(pwd)"
FORTCOV_EXCLUDE_DEFAULT="build/*,test/*"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() {
    echo -e "${BLUE}INFO:${NC} $1"
}

print_success() {
    echo -e "${GREEN}SUCCESS:${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}WARNING:${NC} $1"
}

print_error() {
    echo -e "${RED}ERROR:${NC} $1"
}

# Function to find fortcov executable
find_fortcov() {
    local fortcov_exe
    
    # Try to find in build directory first
    fortcov_exe=$(find build -name "fortcov" -type f -executable 2>/dev/null | head -1)
    
    if [ -n "$fortcov_exe" ]; then
        echo "$fortcov_exe"
        return 0
    fi
    
    # Try system PATH
    if command -v fortcov >/dev/null 2>&1; then
        echo "fortcov"
        return 0
    fi
    
    print_error "fortcov executable not found. Run 'fpm build' first."
    return 1
}

# Function to generate coverage with simple pattern emulation
generate_simple_coverage() {
    local source_pattern="$1"
    local output_file="${2:-coverage.md}"
    local exclude_pattern="${3:-$FORTCOV_EXCLUDE_DEFAULT}"
    
    print_info "Starting FPM coverage generation using simple pattern emulation..."
    
    # Step 1: Clean any existing coverage data (but preserve build system files)
    print_info "Cleaning previous coverage data..."
    rm -f *.gcov *.gcda *.gcno
    # Clean only user-generated .gcov files, but preserve build system .gcno/.gcda files
    find . -maxdepth 1 -name "*.gcov" -delete 2>/dev/null || true
    # Remove .gcda files from project root but NOT from build directories (they'll be regenerated by fpm test)
    find . -maxdepth 1 -name "*.gcda" -delete 2>/dev/null || true
    # Remove .gcno files from project root but NOT from build directories (needed for gcov)
    find . -maxdepth 1 -name "*.gcno" -delete 2>/dev/null || true
    
    # Step 2: Build with coverage flags - single-step approach to prevent timestamp mismatches
    print_info "Building with coverage instrumentation..."
    print_info "Using single-step FPM test approach to ensure gcno/gcda compatibility..."
    
    # Clean any stale coverage files from previous runs
    find build -name "*.gcno" -delete 2>/dev/null || true
    find build -name "*.gcda" -delete 2>/dev/null || true
    
    # Single step: FPM test with coverage flags generates both .gcno and .gcda files with matching timestamps
    print_info "Running FPM test with coverage instrumentation..."
    fpm test --flag "-fprofile-arcs -ftest-coverage"
    
    # Verify both file types exist after single-step approach
    local gcno_final gcda_final
    gcno_final=$(find build -name "*.gcno" | wc -l)
    gcda_final=$(find build -name "*.gcda" | wc -l)
    print_info "Generated coverage files: $gcno_final .gcno files, $gcda_final .gcda files"
    
    # Step 3: Handle the complex FPM build directory structure
    print_info "Extracting coverage data from FPM build directories..."
    
    # Find build directories with coverage data
    local build_dirs
    build_dirs=$(find build -name "*.gcda" | xargs dirname | sort -u 2>/dev/null || true)
    
    if [ -z "$build_dirs" ]; then
        print_error "No coverage data (.gcda files) found in build directories"
        print_error "Make sure FPM compiled with coverage flags: --flag \"-fprofile-arcs -ftest-coverage\""
        return 1
    fi
    
    print_info "Found coverage data in build directories:"
    echo "$build_dirs" | while read -r dir; do
        echo "  - $dir"
    done
    
    # Step 4: Generate .gcov files - CRITICAL FIX: Run gcov FROM WITHIN build directories
    print_info "Generating .gcov files from build directories..."
    local total_gcov_generated=0
    
    echo "$build_dirs" | while read -r build_dir; do
        if [ -n "$build_dir" ] && [ -d "$build_dir" ]; then
            print_info "Processing: $build_dir"
            # Check for .gcno files in the build directory
            if ls "$build_dir"/*.gcno >/dev/null 2>&1; then
                print_info "Found .gcno files in $build_dir"
                
                # Verify gcno/gcda compatibility before running gcov
                local gcno_count gcda_count
                gcno_count=$(ls "$build_dir"/*.gcno 2>/dev/null | wc -l)
                gcda_count=$(ls "$build_dir"/*.gcda 2>/dev/null | wc -l)
                
                print_info "Coverage file counts: $gcno_count .gcno files, $gcda_count .gcda files"
                
                if [ "$gcno_count" -gt 0 ] && [ "$gcda_count" -gt 0 ]; then
                    # CRITICAL FIX: Run gcov FROM WITHIN the build directory
                    print_info "Running gcov from within build directory (timestamp compatibility fix)..."
                    (
                        cd "$build_dir" || exit 1
                        gcov *.gcno 2>/dev/null || true
                        local gcov_count
                        gcov_count=$(ls *.gcov 2>/dev/null | wc -l || echo "0")
                        print_info "Generated $gcov_count .gcov files in $build_dir"
                        
                        # Move .gcov files to project root for organization
                        if [ "$gcov_count" -gt 0 ]; then
                            print_info "Moving .gcov files to project root..."
                            mv *.gcov "$PROJECT_ROOT/" 2>/dev/null || true
                            total_gcov_generated=$((total_gcov_generated + gcov_count))
                        fi
                    )
                else
                    print_warning "Incomplete coverage data: missing gcno or gcda files"
                fi
            else
                print_warning "No .gcno files found in $build_dir - check coverage instrumentation"
                print_warning "gcda files present: $(ls "$build_dir"/*.gcda 2>/dev/null | wc -l)"
            fi
        fi
    done
    
    print_info "Total .gcov files generated across all build directories: checking project root..."
    
    # Step 5: .gcov files are now ready for organization (integrated into Step 6)
    
    # Step 6: Verify .gcov files are available for analysis
    local gcov_in_root
    gcov_in_root=$(find . -maxdepth 1 -name "*.gcov" 2>/dev/null | wc -l)
    
    if [ "$gcov_in_root" -eq 0 ]; then
        print_error "No .gcov files found in project root after processing"
        print_error "This indicates a problem with the gcov generation process"
        print_error "Debug info:"
        print_error "  - Build directories found: $(echo "$build_dirs" | wc -l)"
        print_error "  - .gcno files available: $(find build -name "*.gcno" | wc -l)"
        print_error "  - .gcda files available: $(find build -name "*.gcda" | wc -l)"
        return 1
    fi
    
    print_success "Generated $gcov_in_root .gcov files in project root"
    
    # CRITICAL FIX: Filter out empty .gcov files (only source reference, no coverage data)
    print_info "Filtering out empty .gcov files (no coverage data)..."
    local meaningful_gcov=0
    local empty_gcov=0
    
    for gcov_file in *.gcov; do
        if [ -f "$gcov_file" ]; then
            local line_count
            line_count=$(wc -l < "$gcov_file")
            if [ "$line_count" -le 1 ]; then
                # Empty or single-line files have no coverage data
                rm "$gcov_file"
                empty_gcov=$((empty_gcov + 1))
            else
                meaningful_gcov=$((meaningful_gcov + 1))
            fi
        fi
    done
    
    print_info "Coverage filtering results:"
    print_info "  - Meaningful coverage files: $meaningful_gcov"
    print_info "  - Empty files removed: $empty_gcov"
    
    if [ "$meaningful_gcov" -eq 0 ]; then
        print_warning "No meaningful coverage data found - this usually means:"
        print_warning "  - Test suite doesn't exercise main application code"
        print_warning "  - Coverage instrumentation didn't capture execution"
        print_warning "  - Source files weren't executed during test run"
        print_warning ""
        print_warning "To get coverage data, you need to run the actual application"
        print_warning "or tests that exercise the main source code modules."
        return 1
    fi
    
    # Now organize meaningful .gcov files according to the requested pattern
    local gcov_files
    case "$source_pattern" in
        "src")
            print_info "Organizing meaningful .gcov files for src/ directory pattern"
            # Keep .gcov files in project root - fortcov correlates them with --source=src
            gcov_files=$meaningful_gcov
            ;;
        ".")
            print_info "Keeping meaningful .gcov files in project root for root pattern"
            gcov_files=$meaningful_gcov
            ;;
        *)
            print_info "Organizing meaningful .gcov files for custom pattern: $source_pattern"
            # Keep files in project root but use custom source path
            gcov_files=$meaningful_gcov
            ;;
    esac
    
    print_success "Ready for analysis: $gcov_files meaningful .gcov files with coverage data"
    
    # Step 7: Run fortcov analysis with meaningful .gcov files  
    print_info "Running fortcov analysis with coverage data..."
    local fortcov_exe
    fortcov_exe=$(find_fortcov) || return 1
    
    # Pass .gcov files as positional arguments along with --source
    local gcov_files_list
    gcov_files_list=$(ls *.gcov 2>/dev/null | tr '\n' ' ')
    
    if [ -n "$gcov_files_list" ]; then
        print_info "Command: $fortcov_exe --source $source_pattern --exclude '$exclude_pattern' --output $output_file $gcov_files_list"
        # shellcheck disable=SC2086
        "$fortcov_exe" --source "$source_pattern" --exclude "$exclude_pattern" --output "$output_file" $gcov_files_list
    else
        print_error "No .gcov files available for analysis after filtering"
        return 1
    fi
    
    print_success "Coverage report generated: $output_file"
    
    # Step 8: Show summary
    print_info "Coverage analysis complete!"
    echo
    echo "Files generated:"
    echo "  - Coverage report: $output_file"
    echo "  - .gcov files in: $source_pattern"
    echo
    echo "Clean up with: rm -f $source_pattern/*.gcov"
}

# Main script logic
main() {
    case "${1:-help}" in
        "src")
            # Emulate: cd src && gcov *.f90 && cd .. && fortcov --source=src
            generate_simple_coverage "src" "${2:-coverage.md}" "${3:-$FORTCOV_EXCLUDE_DEFAULT}"
            ;;
        "root"|".")
            # Emulate: gcov src/*.f90 && fortcov --source . --exclude 'build/*' --exclude 'test/*'
            generate_simple_coverage "." "${2:-coverage.md}" "${3:-$FORTCOV_EXCLUDE_DEFAULT}"
            ;;
        "custom")
            # Custom source directory
            if [ -z "$2" ]; then
                print_error "Custom mode requires source directory: $0 custom <source_dir> [output_file] [exclude_pattern]"
                exit 1
            fi
            generate_simple_coverage "$2" "${3:-coverage.md}" "${4:-$FORTCOV_EXCLUDE_DEFAULT}"
            ;;
        "help"|*)
            echo "FPM Coverage Bridge Script"
            echo "Bridges simple README patterns with complex FPM build directory handling"
            echo
            echo "Usage:"
            echo "  $0 src [output_file] [exclude_pattern]"
            echo "    Emulates: cd src && gcov *.f90 && fortcov --source=src"
            echo
            echo "  $0 root [output_file] [exclude_pattern]"
            echo "    Emulates: gcov src/*.f90 && fortcov --source . --exclude 'build/*' --exclude 'test/*'"
            echo
            echo "  $0 custom <source_dir> [output_file] [exclude_pattern]"
            echo "    Custom source directory pattern"
            echo
            echo "Examples:"
            echo "  $0 src                     # Simple src/ pattern -> coverage.md"
            echo "  $0 root coverage.html      # Project root pattern -> coverage.html"
            echo "  $0 custom analysis         # Custom directory pattern"
            echo
            echo "Default exclude pattern: $FORTCOV_EXCLUDE_DEFAULT"
            ;;
    esac
}

# Run main function with all arguments
main "$@"